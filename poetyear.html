<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2026年开场白 - 岁华纪丽</title>
    <style>
        :root {
            --palace-red: #8B1A1A;
            --gold: #D4AF37;
            --white: #FFFFFF;
            --paper: #f4f0e6;
        }

        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background-color: #000;
            font-family: "Noto Serif SC", "Source Han Serif SC", "SimSun", serif;
        }

        /* 核心背景：三张图片的深度处理 */
        #bg-stage {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 0; overflow: hidden;
        }
        .bg-layer {
            position: absolute; width: 110%; height: 110%;
            top: -5%; left: -5%;
            background-size: cover; background-position: center;
            opacity: 0; transition: opacity 2s ease-in-out, transform 1s ease-out;
            filter: brightness(0.7) sepia(0.2);
        }
        .bg-layer.active { opacity: 1; }

        /* 故宫红渐变蒙层 */
        #vignette {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1; pointer-events: none;
            background: radial-gradient(circle, transparent 30%, rgba(139, 26, 26, 0.5) 100%);
        }

        #canvas-container {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 2; pointer-events: none;
        }

        /* UI逻辑 */
        #ui-layer {
            position: relative; z-index: 10; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }

        /* 唯美开屏 */
        #intro-screen {
            text-align: center; color: var(--white); cursor: pointer; pointer-events: all;
            border: 1px solid rgba(212, 175, 55, 0.4); padding: 60px;
            background: rgba(139, 26, 26, 0.2); backdrop-filter: blur(10px);
        }
        .intro-title {
            font-size: 3rem; letter-spacing: 1.2rem; margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(212,175,55,0.6); font-weight: 200;
        }
        .intro-sub { color: var(--gold); letter-spacing: 0.5rem; margin-bottom: 40px; }

        /* 诗词卡片系统 - 高级典雅 */
        #card-container {
            position: absolute; width: 100%; height: 100%;
            display: none; justify-content: center; align-items: center;
            pointer-events: all;
        }
        .poem-card {
            background: var(--paper); width: 340px; min-height: 500px;
            padding: 50px 30px; box-shadow: 0 50px 100px rgba(0,0,0,0.8);
            border: 2px solid var(--gold); position: relative;
            opacity: 0; transform: translateY(50px);
            transition: all 1s cubic-bezier(0.2, 1, 0.3, 1);
            display: flex; flex-direction: column; align-items: center;
        }
        .poem-card.active { opacity: 1; transform: translateY(0); }

        .poem-main {
            writing-mode: vertical-rl; font-size: 2.5rem; height: 320px;
            color: #1a1a1a; letter-spacing: 0.8rem; line-height: 1.5;
            padding-right: 20px; border-right: 1px solid rgba(212, 175, 55, 0.3);
            margin: 0 auto;
        }
        .poem-sub {
            margin-top: 40px; font-size: 0.9rem; color: #555; line-height: 1.8;
            text-align: justify; border-top: 1px dashed var(--gold); padding-top: 20px;
        }

        /* 装饰角 */
        .decor { position: absolute; width: 40px; height: 40px; border: 2px solid var(--gold); }
        .tl { top: 15px; left: 15px; border-right: none; border-bottom: none; }
        .br { bottom: 15px; right: 15px; border-left: none; border-top: none; }

        #webcam { display: none; }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>
</head>
<body>

    <!-- 背景素材映射 -->
    <div id="bg-stage">
        <!-- 请确保图片名正确，或者将这里的 URL 替换为你图片的 base64/在线地址 -->
        <div class="bg-layer active" id="layer1" style="background-image: url('1.jpg')"></div>
        <div class="bg-layer" id="layer2" style="background-image: url('2.jpg')"></div>
        <div class="bg-layer" id="layer3" style="background-image: url('3.jpg')"></div>
    </div>
    
    <div id="vignette"></div>
    <video id="webcam" autoplay playsinline></video>
    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div id="intro-screen" onclick="app.start()">
            <div class="intro-title">用诗意开启你的2026</div>
            <div class="intro-sub">岁华纪丽 · 雪落紫禁</div>
            <button style="background:transparent; border:1px solid var(--gold); color:var(--gold); padding:10px 30px; cursor:pointer;">开启开场白</button>
        </div>
        <div id="card-container"></div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        const POEMS = [
            { m: "老去又逢新岁月，春来更有好花枝。", s: "虽然人已经年老，但迎来了新的岁月，春天到来时更会有美丽的花朵盛开。你要自信、坚定地迎接。" },
            { m: "但得老亲常健好，不辞新岁且穷忙。", s: "祝愿家中父母长辈身体健康安好。家是温暖的港湾，只要他们在，我们就有归处。" },
            { m: "韶华长在，明年依旧，相与笑春风。", s: "岁月悠悠，明年花儿依然绽放。快乐的场景和时光置换了，时光不老，我们不散。" },
            { m: "一年忧喜今宵过，两鬓风霜明日新。", s: "旧年的快忧都过去了，学会“翻篇”的能力。封存往事，展望新年。" },
            { m: "更祝明朝风日好，梅花满眼踏新年。", s: "衷心祝愿明天风和日丽，满眼都是盛开的梅花，迎接新一年的到来。" },
            { m: "新春嘉平，长乐未央。", s: "天地有序，昼夜相承。白日虽有黄昏，夜色仍有月华。起落本常态，低谷亦有光。" },
            { m: "历添新岁月，春满旧山河。", s: "山河依旧，却因春意而焕然一新。不必换一片天地，也能迎来万物复苏的光景。" },
            { m: "但愿年年，春风有信，人心长久。", s: "寄托对世事守约的期待，落笔于人世最珍贵的情感——信任、陪伴与恒常。" },
            { m: "岁岁年年，共欢同乐。", s: "好光景不止于一时，而是有人同行、有人分享。真正的喜悦是彼此照见的温暖。" },
            { m: "休将旧事从头说，且喜新年入手来。", s: "不必反复回顾往昔。新年不再是遥远的期盼，而是握在掌中的现实。重心永远在正在展开的这一页。" }
        ];

        // GLSL: 极其精致的雪花
        const snowVS = `
            uniform float uTime;
            uniform vec2 uMouse;
            varying float vAlpha;
            void main() {
                vec3 pos = position;
                // 模拟雪花轻盈飘落
                pos.x += sin(uTime * 0.5 + pos.y * 0.1) * 2.0;
                pos.y = mod(pos.y - uTime * 6.0, 100.0) - 50.0;
                
                // 鼠标/手势排斥
                float dist = distance(pos.xy, uMouse * 50.0);
                if(dist < 15.0) pos.x += (pos.x - uMouse.x * 50.0) * 0.5;

                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_PointSize = 4.0 * (100.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
                vAlpha = smoothstep(-50.0, -30.0, pos.y);
            }
        `;

        const snowFS = `
            varying float vAlpha;
            void main() {
                float d = distance(gl_PointCoord, vec2(0.5));
                if(d > 0.5) discard;
                gl_FragColor = vec4(1.0, 1.0, 1.0, (0.5-d) * vAlpha * 1.5);
            }
        `;

        class PalaceExperience {
            constructor() {
                this.initThree();
                this.initSnow();
                this.initMediaPipe();
                this.bindEvents();
                this.currentCard = 0;
            }

            initThree() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
                this.camera.position.z = 50;
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);
                
                this.mouse = new THREE.Vector2();
                this.clock = new THREE.Clock();
            }

            initSnow() {
                const geo = new THREE.BufferGeometry();
                const pos = [];
                for(let i=0; i<5000; i++) {
                    pos.push((Math.random()-0.5)*150, (Math.random()-0.5)*100, (Math.random()-0.5)*100);
                }
                geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
                this.snowMat = new THREE.ShaderMaterial({
                    uniforms: { uTime: {value:0}, uMouse: {value: this.mouse} },
                    vertexShader: snowVS, fragmentShader: snowFS, transparent: true
                });
                this.scene.add(new THREE.Points(geo, this.snowMat));
            }

            async initMediaPipe() {
                try {
                    const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                    this.handLandmarker = await HandLandmarker.createFromOptions(vision, {
                        baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                        runningMode: "VIDEO", numHands: 1
                    });
                    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                    document.getElementById('webcam').srcObject = stream;
                } catch(e) { console.log("MediaPipe offline"); }
            }

            bindEvents() {
                window.addEventListener('mousemove', (e) => {
                    const x = (e.clientX / window.innerWidth) * 2 - 1;
                    const y = -(e.clientY / window.innerHeight) * 2 + 1;
                    this.mouse.set(x, y);
                    // 背景视觉差
                    const layers = document.querySelectorAll('.bg-layer');
                    layers.forEach(l => {
                        l.style.transform = `translate(${x * 20}px, ${y * 20}px) scale(1.1)`;
                    });
                });
            }

            start() {
                document.getElementById('intro-screen').style.opacity = '0';
                setTimeout(() => {
                    document.getElementById('intro-screen').style.display = 'none';
                    document.getElementById('card-container').style.display = 'flex';
                    this.showCard();
                }, 1000);
            }

            showCard() {
                if(this.currentCard >= 10) return;
                
                // 切换背景图
                const layers = document.querySelectorAll('.bg-layer');
                layers.forEach(l => l.classList.remove('active'));
                const layerId = (this.currentCard % 3) + 1;
                document.getElementById('layer' + layerId).classList.add('active');

                const container = document.getElementById('card-container');
                container.innerHTML = '';
                const data = POEMS[this.currentCard];
                
                const card = document.createElement('div');
                card.className = 'poem-card';
                card.innerHTML = `
                    <div class="decor tl"></div><div class="decor br"></div>
                    <div class="poem-main">${data.m}</div>
                    <div class="poem-sub">${data.s}</div>
                    <div style="margin-top:20px; color:var(--gold); font-size:0.8rem;">点击屏幕 踏雪寻下一句</div>
                `;
                
                card.onclick = () => {
                    card.classList.remove('active');
                    setTimeout(() => {
                        this.currentCard++;
                        this.showCard();
                    }, 800);
                };

                container.appendChild(card);
                setTimeout(() => card.classList.add('active'), 100);
            }

            animate() {
                requestAnimationFrame(this.animate.bind(this));
                const delta = this.clock.getElapsedTime();
                this.snowMat.uniforms.uTime.value = delta;

                // MediaPipe 手势追踪驱动雪花
                if (this.handLandmarker && webcam.readyState >= 2) {
                    const results = this.handLandmarker.detectForVideo(webcam, performance.now());
                    if (results.landmarks.length > 0) {
                        const hand = results.landmarks[0][8]; // 食指
                        this.mouse.lerp(new THREE.Vector2((0.5 - hand.x) * 2, (0.5 - hand.y) * 2), 0.1);
                    }
                }

                this.renderer.render(this.scene, this.camera);
            }
        }

        window.app = new PalaceExperience();
        app.animate();
    </script>
</body>
</html>
